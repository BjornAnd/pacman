<head>
<script>

//
// =========== TILE MAP ============
//

var tileCols = 28;
var tileRows = 36;

// initial tile state
var tiles = (
"____________________________" +
"____________________________" +
"____________________________" +
"||||||||||||||||||||||||||||" +
"|............||............|" +
"|.||||.|||||.||.|||||.||||.|" +
"|o|__|.|___|.||.|___|.|__|o|" +
"|.||||.|||||.||.|||||.||||.|" +
"|..........................|" +
"|.||||.||.||||||||.||.||||.|" +
"|.||||.||.||||||||.||.||||.|" +
"|......||....||....||......|" +
"||||||.||||| || |||||.||||||" +
"_____|.||||| || |||||.|_____" +
"_____|.||          ||.|_____" +
"_____|.|| |||--||| ||.|_____" +
"||||||.|| |______| ||.||||||" +
"      .   |______|   .      " +
"||||||.|| |______| ||.||||||" +
"_____|.|| |||||||| ||.|_____" +
"_____|.||          ||.|_____" +
"_____|.||.||||||||.||.|_____" +
"||||||.||.||||||||.||.||||||" +
"|............||............|" +
"|.||||.|||||.||.|||||.||||.|" +
"|.||||.|||||.||.|||||.||||.|" +
"|o..||.......  .......||..o|" +
"|||.||.||.||||||||.||.||.|||" +
"|||.||.||.||||||||.||.||.|||" +
"|......||....||....||......|" +
"|.||||||||||.||.||||||||||.|" +
"|.||||||||||.||.||||||||||.|" +
"|..........................|" +
"||||||||||||||||||||||||||||" +
"____________________________" +
"____________________________");

// current tile state
var currentTiles;
var resetTiles = function() {
    currentTiles = tiles.split("");
};

// offscreen tiles for tunnel
var isOffscreenTunnelTile = function(x,y) {
    return (y == 17 && (x<0 || x>tileCols-1));
};
var getTile = function(x,y) {
    if (x>=0 && x<tileCols && y>=0 && y<tileRows) 
        return currentTiles[x+y*tileCols];
    if (isOffscreenTunnelTile(x,y))
        return ' ';
};

//
// ========== TILE DRAWING ============
//

var size = 8;         // tile size
var mid = {x:3, y:4}; // x,y center of a tile

var drawBackground = function() {
    ctx.fillStyle = "#333";
    ctx.fillRect(0,0,ctx_w,ctx_h);
};
var drawPill = function(x,y,c,s) {
    ctx.fillStyle = c;
    ctx.fillRect(x*size + mid.x - s/2, y*size + mid.y - s/2, s, s);
};
var drawFloor = function(x,y,c,p) {
    ctx.fillStyle = c;
    ctx.fillRect(x*size+p,y*size+p,size-2*p,size-2*p);
};
var drawActor = function(px,py,c,s) {
    ctx.fillStyle = c;
    ctx.fillRect(px-s/2, py-s/2, s, s);
};

var cellDraw = {};
cellDraw['|'] = function(x,y) { }; // wall
cellDraw['.'] = function(x,y) { drawFloor(x,y,"#888",0); }; // pellet
cellDraw['o'] = function(x,y) { drawFloor(x,y,"#FFF",0); }; // energizer
cellDraw[' '] = function(x,y) { drawFloor(x,y,"#555",0); }; // walkable space
cellDraw['_'] = function(x,y) { }; // dead space
cellDraw['-'] = function(x,y) { }; // ghost door

var isTileWalkable = function(t) {
    return t==' ' || t=='.' || t=='o';
};

var drawTiles = function () {
    var x,y;
    var i=0;
    for (y=0; y<tileRows; y++)
    for (x=0; x<tileCols; x++)
        cellDraw[currentTiles[i++]](x,y);
};

//
// ============ TILE DIRECTION ============
// 

// direction enums (in order of ghost turn preference)
var DIR_UP = 0;
var DIR_LEFT = 1;
var DIR_DOWN = 2;
var DIR_RIGHT = 3;

// get direction enum from a direction vector
var getEnumFromDir = function(dir) {
    if (dir.x==-1) return DIR_LEFT;
    if (dir.x==1) return DIR_RIGHT;
    if (dir.y==-1) return DIR_UP;
    if (dir.y==1) return DIR_DOWN;
};

// set direction vector from a direction enum
var setDirFromEnum = function(dir,dirEnum) {
    if (dirEnum == DIR_UP)         { dir.x = 0; dir.y =-1; }
    else if (dirEnum == DIR_LEFT)  { dir.x =-1; dir.y = 0; }
    else if (dirEnum == DIR_DOWN)  { dir.x = 0; dir.y = 1; }
    else if (dirEnum == DIR_RIGHT) { dir.x = 1; dir.y = 0; }
};

// get a list of the four surrounding tiles
var getSurroundingTiles = function(tile) {
    return [
        getTile(tile.x, tile.y-1), // DIR_UP
        getTile(tile.x-1, tile.y), // DIR_LEFT
        getTile(tile.x, tile.y+1), // DIR_DOWN
        getTile(tile.x+1, tile.y)  // DIR_RIGHT
    ];
};

// get a tile next to the given tile
var getNextTile = function(tile, dir) {
    return getTile(tile.x+dir.x, tile.y+dir.y);
};

//
// ============ ACTOR SPEEDS ============
//

// speed control table (from Jamey Pittman)
var stepSizes = (
                     // LEVEL 1
"1111111111111111" + // pac-man (normal)
"0111111111111111" + // ghosts (normal)
"1111211111112111" + // pac-man (fright)
"0110110101101101" + // ghosts (fright)
"0101010101010101" + // ghosts (tunnel)
"1111111111111111" + // elroy 1
"1111111121111111" + // elroy 2

                     // LEVELS 2-4
"1111211111112111" + // pac-man (normal)
"1111111121111111" + // ghosts (normal)
"1111211112111121" + // pac-man (fright)
"0110110110110111" + // ghosts (fright)
"0110101011010101" + // ghosts (tunnel)
"1111211111112111" + // elroy 1
"1111211112111121" + // elroy 2

                     // LEVELS 5-20
"1121112111211121" + // pac-man (normal)
"1111211112111121" + // ghosts (normal)
"1121112111211121" + // pac-man (fright) (N/A for levels 17, 19 & 20)
"0111011101110111" + // ghosts (fright)  (N/A for levels 17, 19 & 20)
"0110110101101101" + // ghosts (tunnel)
"1121112111211121" + // elroy 1
"1121121121121121" + // elroy 2

                     // LEVELS 21+
"1111211111112111" + // pac-man (normal)
"1111211112111121" + // ghosts (normal)
"0000000000000000" + // pac-man (fright) N/A
"0000000000000000" + // ghosts (fright)  N/A
"0110110101101101" + // ghosts (tunnel)
"1121112111211121" + // elroy 1
"1121121121121121"); // elroy 2

// used as "pattern" parameter in getStepSize()
var STEP_PACMAN = 0;
var STEP_GHOST = 1;
var STEP_PACMAN_FRIGHT = 2;
var STEP_GHOST_FRIGHT = 3;
var STEP_GHOST_TUNNEL = 4;
var STEP_ELROY1 = 5;
var STEP_ELROY2 = 6;

// getter function to extract a step size from the table
var getStepSize = function(level, pattern, frame) {
    var entry;
    if (level < 1) return;
    else if (level==1)                  entry = 0;
    else if (level >= 2 && level <= 4)  entry = 1;
    else if (level >= 5 && level <= 20) entry = 2;
    else if (level >= 21)               entry = 3;
    return stepSizes[entry*7*16 + pattern*16 + frame%16];
};

//
// ============= COMMON ACTOR ==============
//

var Actor = function() {
    this.mode = 0;
    this.startPos = {};    // x,y pixel starting position (0<=x<tileCols*size, 0<=y<tileRows*size)
    this.startDirEnum = 0; // starting direction enumeration (0<=x,y<=4)
    this.tile = {};        // x,y tile position (0<=x<tileCols, 0<=y<tileRows)
    this.pixel = {};       // x,y pixel position (0<=x<tileCols*size, 0<=y<tileRows*size)
    this.tilePixel = {};   // x,y pixel in tile (0<=x,y<size)
    this.distToMid = {};   // x,y pixel distance from center of tile
    this.dir = {};         // x,y direction (-1<=x,y<=1)
    this.dirEnum = 0;      // direction enumeration (0<=x,y<=4)
    this.frame = 0;        // frame count
    this.color = 0;
};

// reset state for start of a level
Actor.prototype.reset = function() {
    this.setDir(this.startDirEnum);
    this.setPos(this.startPos.x, this.startPos.y);
};

// sets the position and updates its dependent variables
Actor.prototype.setPos = function(px,py) {
    this.pixel.x = px;
    this.pixel.y = py;
    this.commitPos();
};

// updates the position's dependent variables
Actor.prototype.commitPos = function() {

    // teleport position to opposite side of map if past tunnel tiles
    // (there are two invisible tiles on each side of the tunnel)
    if (isOffscreenTunnelTile(this.tile.x, this.tile.y))
        if (this.pixel.x == -2*size-1)
            this.pixel.x = (tileCols+2)*size-1;
        else if (this.pixel.x == (tileCols+2)*size)
            this.pixel.x = -2*size;

    this.tile.x = Math.floor(this.pixel.x / size);
    this.tile.y = Math.floor(this.pixel.y / size);
    this.tilePixel.x = this.pixel.x % size;
    this.tilePixel.y = this.pixel.y % size;
    this.distToMid.x = mid.x - this.tilePixel.x;
    this.distToMid.y = mid.y - this.tilePixel.y;
};

// sets the direction and updates its dependent variables
Actor.prototype.setDir = function(dirEnum) {
    setDirFromEnum(this.dir, dirEnum);
    this.dirEnum = dirEnum;
};

// updates the actor state
Actor.prototype.update = function() {
    // get number of steps to advance in this frame
    var steps = getStepSize(level, this.getStepPattern(), this.frame);
    var i;
    for (i=0; i<steps; i++) {
        this.step();
        this.steer();
    }
    this.frame += 1;
};

// draws the actor
Actor.prototype.draw = function() {
    drawActor(this.pixel.x, this.pixel.y, this.color, 20);
};

//
// ============== GHOST ACTOR ==============
//

var MODE_GHOST_CHASE = 0;
var MODE_GHOST_SCATTER = 1;
var MODE_GHOST_FRIGHT = 2;

// Ghost constructor
var Ghost = function() {
    Actor.apply(this);    // inherit data from Actor
    this.target = {x:0,y:0};     // x,y target tile (0<=x<tileCols, 0<=y<tileRows)
    this.home = {};       // x,y home tile (0<=x<tileCols, 0<=y<tileRows)
    this.color = 0;
    this.reverse = false; // reverse signal
    this.reverseTile = {}; // x,y tile to reverse direction after leaving
};
Ghost.prototype.__proto__ = Actor.prototype; // inherit functions from Actor

// gets the step pattern (speed) used in speed control table
Ghost.prototype.getStepPattern = function() {
    // TODO: override this function for blinky to trigger elroy states
    var pattern;
    if (this.mode == MODE_GHOST_CHASE || this.mode == MODE_GHOST_SCATTER) {
        if (this.tile.y == 17 && (this.tile.x <= 5 || this.tile.x >= tileCols-1-5))
            return STEP_GHOST_TUNNEL;
        return STEP_GHOST;
    }
    else
        return STEP_GHOST_FRIGHT;
};

// move forward
Ghost.prototype.step = function() {
    this.setPos(this.pixel.x+this.dir.x, this.pixel.y+this.dir.y);
};

// make ghost reverse direction after leaving current tile
Ghost.prototype.signalReverse = function() {
    this.reverseTile.x = this.tile.x;
    this.reverseTile.y = this.tile.y;
    this.reverse = true;
}

// determine direction
Ghost.prototype.steer = function() {
    var dirEnum;
    var blocked;

    var dir = {};
    var oppDirEnum = (this.dirEnum+2)%4;
    var i,dx,dy;
    var dist,minDist = Infinity;

    var surroundTiles;

    // reverse direction once we exit the tile occupied when reverse signal was given
    if (this.reverse && !(this.tile.x == this.reverseTile.x && this.tile.y == this.reverseTile.y)) {
        this.reverse = false;
        this.setDir(oppDirEnum);
    }

    // only steer at mid tile
    if (this.tilePixel.x != mid.x || this.tilePixel.y != mid.y)
        return;

    // get blocked passages
    surroundTiles = getSurroundingTiles(this.tile);
    blocked = [1,1,1,1];
    for (i=0; i<4; i++) {
        blocked[i] = !isTileWalkable(surroundTiles[i]);
    }

    // not allowed to turn around
    blocked[oppDirEnum] = true;

    // random turn if frightened
    if (this.mode == MODE_GHOST_FRIGHT) {
        dirEnum = Math.floor(Math.random()*5);
        while (blocked[dirEnum])
            dirEnum = (dirEnum+1)%4;
    }
    else {
        // set target
        if (this.mode == MODE_GHOST_SCATTER) {
            this.target.x = this.home.x;
            this.target.y = this.home.y;
        }
        else // mode == MODE_GHOST_CHASE
            this.setTarget();

        // not allowed to go up at these points
        if ((this.tile.x == 12 || this.tile.x == 15) && (this.tile.y == 14 || this.tile.y == 26))
            blocked[DIR_UP] = true;

        // choose direction that minimizes distance to target
        for (i=0; i<4; i++) if (!blocked[i]) {
            setDirFromEnum(dir,i);
            dx = dir.x + this.tile.x - this.target.x;
            dy = dir.y + this.tile.y - this.target.y;
            dist = dx*dx+dy*dy;
            if (dist < minDist) {
                minDist = dist;
                dirEnum = i;
            }
        }
    }

    // commit the direction
    this.setDir(dirEnum);
};

// draw the line of sight of the ghost
Ghost.prototype.drawSight = function() {
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.pixel.x, this.pixel.y);
    ctx.lineTo(this.target.x*size+mid.x, this.target.y*size+mid.y);
    ctx.closePath();
    ctx.stroke();
    drawFloor(this.target.x,this.target.y, this.color,1);
};

//
// ============== PLAYER ACTOR ==============
//

var MODE_PLAYER_NORM = 0;
var MODE_PLAYER_ENERGY = 1;

// Pacman constructor
var Player = function() {
    Actor.apply(this);    // inherit data from Actor
    this.nextDir = {};    // x,y direction which reflects the player's controls
    this.nextDirEnum = 0; // direction enumeration for nextDir
};
Player.prototype.__proto__ = Actor.prototype; // inherit functions from Actor

// sets the next direction and updates its dependent variables
Player.prototype.setNextDir = function(nextDirEnum) {
    setDirFromEnum(this.nextDir, nextDirEnum);
    this.nextDirEnum = nextDirEnum;
};

// gets the step pattern (speed) used in speed control table
Player.prototype.getStepPattern = function() {
    var pattern;
    if (this.mode == MODE_PLAYER_NORM) 
        return STEP_PACMAN;
    else if (this.mode == MODE_PLAYER_ENERGY) 
        return STEP_PACMAN_FRIGHT;
};

// move forward
Player.prototype.step = function() {

    var a = (this.dir.x != 0) ? 'x' : 'y'; // axis of motion
    var b = (this.dir.x != 0) ? 'y' : 'x'; // axis perpendicular to motion

    // Don't proceed past the middle of a tile if facing a wall
    var stop = this.distToMid[a] == 0 && !isTileWalkable(getNextTile(this.tile, this.dir));
    if (!stop)
        this.pixel[a] += this.dir[a];

    // Drift toward the center of the track (a.k.a. cornering)
    this.pixel[b] += sign(this.distToMid[b]);

    this.commitPos();

    // TODO: HANDLE EATING:
    // stop for 1 frame when eat pill
    // reverse ghost direction when eat energizer
    // increase speed when eat energizer and stop for 3 frames
};

// determine direction
Player.prototype.steer = function() {
    // head in the desired direction if possible
    if (isTileWalkable(getNextTile(this.tile, this.nextDir)))
        this.setDir(this.nextDirEnum);
};

//
// ================ ACTOR DEFINITIONS ==============
// 

// create blinky
var blinky = new Ghost();
blinky.color = "#FF0000";
blinky.startDirEnum = DIR_LEFT;
blinky.startPos.x = size*tileCols/2;
blinky.startPos.y = 14*size+mid.y;
blinky.home.x = tileCols-1-2;
blinky.home.y = 0;
blinky.setTarget = function() {
    // directly target pacman
    this.target.x = pacman.tile.x;
    this.target.y = pacman.tile.y;
};

// create pinky
var pinky = new Ghost();
pinky.color = "#FFB8FF";
pinky.startDirEnum = DIR_RIGHT;
pinky.startPos.x = size*tileCols/2;
pinky.startPos.y = 20*size+mid.y;
pinky.home.x = 2;
pinky.home.y = 0;
pinky.setTarget = function() {
    // target four tiles ahead of pacman
    this.target.x = pacman.tile.x + 4*pacman.dir.x;
    this.target.y = pacman.tile.y + 4*pacman.dir.y;
    if (pacman.dirEnum == DIR_UP)
        this.target.x -= 4; // arcade overflow bug
};

// create inky
var inky = new Ghost();
inky.color = "#00FFFF";
inky.startDirEnum = DIR_DOWN;
inky.startPos.x = 9*size + mid.x;
inky.startPos.y = 17*size + mid.y;
inky.home.x = 0;
inky.home.y = tileRows - 2;
inky.setTarget = function() {
    // target twice the distance from blinky to two tiles ahead of pacman
    var px = pacman.tile.x + 2*pacman.dir.x;
    var py = pacman.tile.y + 2*pacman.dir.y;
    if (pacman.dirEnum == DIR_UP)
        px -= 2; // arcade overflow bug
    this.target.x = blinky.tile.x + 2*(px - blinky.tile.x);
    this.target.y = blinky.tile.y + 2*(py - blinky.tile.y);
};

// create clyde
var clyde = new Ghost();
clyde.color = "#FFB851";
clyde.startDirEnum = DIR_RIGHT;
clyde.startPos.x = 18*size + mid.x;
clyde.startPos.y = 17*size + mid.y;
clyde.home.x = tileCols-1;
clyde.home.y = tileRows-2;
clyde.setTarget = function() {
    // target pacman if >=8 tiles away, otherwise go home
    var dx = pacman.tile.x - this.tile.x;
    var dy = pacman.tile.y - this.tile.y;
    var dist = dx*dx+dy*dy;
    if (dist >= 64) {
        this.target.x = pacman.tile.x;
        this.target.y = pacman.tile.y;
    }
    else {
        this.target.x = this.home.x;
        this.target.y = this.home.y;
    }
};

var ghosts = [ blinky, pinky, inky, clyde ];

// create pacman
var pacman = new Player();
pacman.color = "#FFFF00";
pacman.startDirEnum = DIR_LEFT;
pacman.startPos.x = size*tileCols/2;
pacman.startPos.y = 26*size + mid.y;

//
// ================ GAME STATES ===================
//

var state; // current state object
var level = 1; // current level

// switch to the given state
var switchToState = function(s) {
    s.init();
    state = s;
};

// start state
var stateStart = {};
stateStart.init = function() {
    resetTiles();
    var i;
    for (i=0; i<4; i++)
        ghosts[i].reset();
    pacman.reset();

    this.frame = 0;
    this.text = "ready";
    this.textWidth = ctx.measureText(this.text).width;
};
stateStart.draw = function() {
    drawBackground();
    drawTiles();
    var i;
    for (i=0; i<4; i++)
        ghosts[i].draw();
    pacman.draw();
    ctx.fillStyle = "#FF0";
    ctx.fillText(this.text, tileCols*size/2 - this.textWidth/2, 17*size+mid.y);
};
stateStart.update = function() {
    if (this.frame == 2*60)
        switchToState(playState);
    this.frame += 1;
};

// play state
var playState = {};
playState.init = function(){};
playState.draw = function() {
    drawBackground();
    drawTiles();
    var i;
    for (i=0; i<4; i++) {
        ghosts[i].draw();
        ghosts[i].drawSight();
    }
    pacman.draw();
};
playState.update = function() {
    var i;
    for (i=0; i<4; i++)
        ghosts[i].update();
    pacman.update();
    // TODO: if collision, state = deadState
    // TODO: if collect all pellets, state = finishState
};

// dead state
var deadState = {};
deadState.init = function() { };
deadState.draw = function() { };
deadState.update = function() { };

// finish state
var finishState = {};
finishState.init = function() { };
finishState.draw = function() { };
finishState.update = function() { };

//
// =============== USER INPUT ==================
//

var initInput = function() {
    // make "focusable" to isolate keypresses when canvas is clicked
    canvas.tabIndex = 0;

    // activate input focus
    canvas.onmousedown = function(e) {
        this.focus();
    };

    // handle key press event
    canvas.onkeydown = function(e) {
        var key = (e||window.event).keyCode;
        switch (key) {
            case 65: case 37: pacman.setNextDir(DIR_LEFT); break; // left
            case 87: case 38: pacman.setNextDir(DIR_UP); break; // up
            case 68: case 39: pacman.setNextDir(DIR_RIGHT); break; // right
            case 83: case 40: pacman.setNextDir(DIR_DOWN); break;// down
        }
    };
};



//
// =========== MAIN SETUP ==========
//

// return sign of a number
var sign = function(x) {
    if (x<0) return -1;
    if (x>0) return 1;
    return 0;
};

var canvas;
var ctx, ctx_w, ctx_h;

window.onload = function() {
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");
    ctx_w = ctx.canvas.width;
    ctx_h = ctx.canvas.height;
    ctx.font = "bold 12px sans-serif";
    initInput();

    this.switchToState(stateStart);
    setInterval("state.update()", 1000/60); // update at 60Hz (original arcade rate)
    setInterval("state.draw()", 1000/25);   // draw at 25Hz (helps performance)
};


//
// ============= END ===============
//
</script>
</head>
<body>
<canvas id="canvas" width="224" height="288" style="border:1px solid #DDD; outline:none;"></canvas>
<p>
based on the <a href="http://home.comcast.net/~jpittman2/pacman/pacmandossier.html">The Pac-Man Dossier</a>.<br/>
project tracked on <a href="https://github.com/shaunew/Pac-Man">GitHub</a>
</p>
</body>
