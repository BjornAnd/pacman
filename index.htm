<head>
<script>

//
// =========== TILE MAP ============
//

var tileCols = 28;
var tileRows = 36;

// initial tile state
var tiles = (
"____________________________" +
"____________________________" +
"____________________________" +
"||||||||||||||||||||||||||||" +
"|............||............|" +
"|.||||.|||||.||.|||||.||||.|" +
"|o|__|.|___|.||.|___|.|__|o|" +
"|.||||.|||||.||.|||||.||||.|" +
"|..........................|" +
"|.||||.||.||||||||.||.||||.|" +
"|.||||.||.||||||||.||.||||.|" +
"|......||....||....||......|" +
"||||||.||||| || |||||.||||||" +
"_____|.||||| || |||||.|_____" +
"_____|.||          ||.|_____" +
"_____|.|| |||--||| ||.|_____" +
"||||||.|| |______| ||.||||||" +
"      .   |______|   .      " +
"||||||.|| |______| ||.||||||" +
"_____|.|| |||||||| ||.|_____" +
"_____|.||          ||.|_____" +
"_____|.||.||||||||.||.|_____" +
"||||||.||.||||||||.||.||||||" +
"|............||............|" +
"|.||||.|||||.||.|||||.||||.|" +
"|.||||.|||||.||.|||||.||||.|" +
"|o..||.......  .......||..o|" +
"|||.||.||.||||||||.||.||.|||" +
"|||.||.||.||||||||.||.||.|||" +
"|......||....||....||......|" +
"|.||||||||||.||.||||||||||.|" +
"|.||||||||||.||.||||||||||.|" +
"|..........................|" +
"||||||||||||||||||||||||||||" +
"____________________________" +
"____________________________");

// current tile state
var currentTiles;
var resetTiles = function() {
    currentTiles = tiles.split("");
};
var getTile = function(x,y) {
    if (x>=0 && x<tileCols && y>=0 && y<tileRows) 
        return currentTiles[x+y*tileCols];
};

//
// ========== TILE DRAWING ============
//

var size = 8; // tile size
var mid = {x:3, y:4};

var drawPill = function(x,y,c,s) {
    ctx.fillStyle = c;
    ctx.fillRect(x*size + mid.x - s/2, y*size + mid.y - s/2, s, s);
};
var drawBlock = function(x,y,c) {
    ctx.fillStyle = c;
    ctx.fillRect(x*size,y*size,size,size);
};
var drawFloor = function(x,y) {
    drawBlock(x,y,"#DDD");
};
var drawActor = function(px,py,c,s) {
    ctx.fillStyle = c;
    ctx.fillRect(px-s/2, py-s/2, s, s);
};

var cellDraw = {};
cellDraw['|'] = function(x,y) { };
cellDraw['.'] = function(x,y) { drawFloor(x,y); drawPill(x,y,"#000",2); };
cellDraw['o'] = function(x,y) { drawFloor(x,y); drawPill(x,y,"#000",6); };
cellDraw[' '] = function(x,y) { drawFloor(x,y); drawPill(x,y,"#FFF",2); };
cellDraw['_'] = function(x,y) { };
cellDraw['-'] = function(x,y) { };

var isTileWalkable = function(t) {
    return t==' ' || t=='.' || t=='o';
};

var drawTiles = function () {
    var x,y;
    var i=0;
    for (y=0; y<tileRows; y++)
    for (x=0; x<tileCols; x++)
        cellDraw[currentTiles[i++]](x,y);
};

//
// ============ TILE DIRECTION ============
// 

// direction enums (in order of ghost turn preference)
var DIR_UP = 0;
var DIR_LEFT = 1;
var DIR_DOWN = 2;
var DIR_RIGHT = 3;

// get direction enum from a direction vector
var getEnumFromDir = function(dir) {
    if (dir.x==-1) return DIR_LEFT;
    if (dir.x==1) return DIR_RIGHT;
    if (dir.y==-1) return DIR_UP;
    if (dir.y==1) return DIR_DOWN;
};

// set direction vector from a direction enum
var setDirFromEnum = function(dir,dirEnum) {
    if (dirEnum == DIR_UP)         { dir.x = 0; dir.y =-1; }
    else if (dirEnum == DIR_LEFT)  { dir.x =-1; dir.y = 0; }
    else if (dirEnum == DIR_DOWN)  { dir.x = 0; dir.y = 1; }
    else if (dirEnum == DIR_RIGHT) { dir.x = 1; dir.y = 0; }
};

// get a list of the four surrounding tiles
var getSurroundingTiles = function(tile) {
    return [
        getTile(tile.x, tile.y-1), // DIR_UP
        getTile(tile.x-1, tile.y), // DIR_LEFT
        getTile(tile.x, tile.y+1), // DIR_DOWN
        getTile(tile.x+1, tile.y)  // DIR_RIGHT
    ];
};

// get a tile next to the given tile
var getNextTile = function(tile, dir) {
    return getTile(tile.x+dir.x, tile.y+dir.y);
};

//
// ============ ACTOR SPEEDS ============
//

// speed control table (from Jamey Pittman)
var stepSizes = (
                     // LEVEL 1
"1111111111111111" + // pac-man (normal)
"0111111111111111" + // ghosts (normal)
"1111211111112111" + // pac-man (fright)
"0110110101101101" + // ghosts (fright)
"0101010101010101" + // ghosts (tunnel)
"1111111111111111" + // elroy 1
"1111111121111111" + // elroy 2

                     // LEVELS 2-4
"1111211111112111" + // pac-man (normal)
"1111111121111111" + // ghosts (normal)
"1111211112111121" + // pac-man (fright)
"0110110110110111" + // ghosts (fright)
"0110101011010101" + // ghosts (tunnel)
"1111211111112111" + // elroy 1
"1111211112111121" + // elroy 2

                     // LEVELS 5-20
"1121112111211121" + // pac-man (normal)
"1111211112111121" + // ghosts (normal)
"1121112111211121" + // pac-man (fright) (N/A for levels 17, 19 & 20)
"0111011101110111" + // ghosts (fright)  (N/A for levels 17, 19 & 20)
"0110110101101101" + // ghosts (tunnel)
"1121112111211121" + // elroy 1
"1121121121121121" + // elroy 2

                     // LEVELS 21+
"1111211111112111" + // pac-man (normal)
"1111211112111121" + // ghosts (normal)
"0000000000000000" + // pac-man (fright) N/A
"0000000000000000" + // ghosts (fright)  N/A
"0110110101101101" + // ghosts (tunnel)
"1121112111211121" + // elroy 1
"1121121121121121"); // elroy 2

// used as "pattern" parameter in getStepSize()
var STEP_PACMAN = 0;
var STEP_GHOST = 1;
var STEP_PACMAN_FRIGHT = 2;
var STEP_GHOST_FRIGHT = 3;
var STEP_GHOST_TUNNEL = 4;
var STEP_ELROY1 = 5;
var STEP_ELROY2 = 6;

// getter function to extract a step size from the table
var getStepSize = function(level, pattern, frame) {
    var entry;
    if (level < 1) return;
    else if (level==1)                  entry = 0;
    else if (level >= 2 && level <= 4)  entry = 1;
    else if (level >= 5 && level <= 20) entry = 2;
    else if (level >= 21)               entry = 3;
    return stepSizes[entry*7*16 + pattern*16 + frame%16];
};

//
// ============= COMMON ACTOR ==============
//

var Actor = function() {
    this.mode = 0;
    this.tile = {};
    this.pixel = {};
    this.tilePixel = {};
    this.distToMid = {};
    this.dir = {};
    this.dirEnum = 0;
    this.frame = 0;
    this.color = 0;
};

// sets the position and updates its dependent variables
Actor.prototype.setPos = function(px,py) {
    this.pixel.x = px;
    this.pixel.y = py;
    this.commitPos();
};

// updates the position's dependent variables
Actor.prototype.commitPos = function() {
    this.tile.x = Math.floor(this.pixel.x / size);
    this.tile.y = Math.floor(this.pixel.y / size);
    this.tilePixel.x = this.pixel.x % size;
    this.tilePixel.y = this.pixel.y % size;
    this.distToMid.x = mid.x - this.tilePixel.x;
    this.distToMid.y = mid.y - this.tilePixel.y;
};

// sets the direction and updates its dependent variables
Actor.prototype.setDir = function(dirEnum) {
    setDirFromEnum(this.dir, dirEnum);
    this.dirEnum = dirEnum;
};

// updates the actor state
Actor.prototype.update = function() {
    // get number of steps to advance in this frame
    var steps = getStepSize(level, this.getStepPattern(), this.frame);
    var i;
    for (i=0; i<steps; i++) {
        this.step();
        this.steer();
    }
    this.frame += 1;
};

// draws the actor
Actor.prototype.draw = function() {
    drawActor(this.pixel.x, this.pixel.y, this.color, 20);
};

//
// ============== GHOST ACTOR ==============
//

var MODE_GHOST_CHASE = 0;
var MODE_GHOST_SCATTER = 1;
var MODE_GHOST_FRIGHT = 2;

var Ghost = function() {
    Actor.apply(this);
    this.target = {}; // target tile
    this.home = {};   // home tile
    this.color = 0;
    this.reverse = false;
};
Ghost.prototype.__proto__ = Actor.prototype;

Ghost.prototype.getStepPattern = function() {
    // TODO: override this function for blinky to trigger elroy states
    // TODO: add tunnel case
    var pattern;
    if (this.mode == MODE_GHOST_CHASE || this.mode == MODE_GHOST_SCATTER)
        return STEP_GHOST;
    else
        return STEP_GHOST_FRIGHT;
};

// move forward
Ghost.prototype.step = function() {
    this.setPos(this.pixel.x+this.dir.x, this.pixel.y+this.dir.y);
};

// determine direction
Ghost.prototype.steer = function() {
    var dirEnum;
    var blocked;

    var dir = {};
    var oppDirEnum = (this.dirEnum+2)%4;
    var i,dx,dy;
    var dist,minDist = Infinity;

    var surroundTiles;

    // only steer at mid tile
    if (this.tilePixel.x != mid.x || this.tilePixel.y != mid.y)
        return;

    // reverse direction if commanded
    if (this.reverse) {
        dirEnum = oppDirEnum;
        this.reverse = false;
    }
    else {
        // get blocked passages
        surroundTiles = getSurroundingTiles(this.tile);
        blocked = [1,1,1,1];
        for (i=0; i<4; i++) {
            blocked[i] = !isTileWalkable(surroundTiles[i]);
        }

        // not allowed to turn around
        blocked[oppDirEnum] = true;

        // random turn if frightened
        if (this.mode == MODE_GHOST_FRIGHT) {
            dirEnum = Math.floor(Math.random()*5);
            while (blocked[dirEnum])
                dirEnum = (dirEnum+1)%4;
        }
        else {
            // set target
            if (this.mode == MODE_GHOST_SCATTER) {
                this.target.x = this.home.x;
                this.target.y = this.home.y;
            }
            else if (this.mode == MODE_GHOST_CHASE) {
                this.target.x = pacman.tile.x;
                this.target.y = pacman.tile.y;
            }

            // not allowed to go up at these points
            if ((this.tile.x == 12 || this.tile.x == 15) && (this.tile.y == 14 || this.tile.y == 26))
                blocked[DIR_UP] = true;

            // choose direction that minimizes distance to target
            for (i=0; i<4; i++) if (!blocked[i]) {
                setDirFromEnum(dir,i);
                dx = dir.x + this.tile.x - this.target.x;
                dy = dir.y + this.tile.y - this.target.y;
                dist = dx*dx+dy*dy;
                if (dist < minDist) {
                    minDist = dist;
                    dirEnum = i;
                }
            }
        }
    }

    // commit the direction
    this.setDir(dirEnum);
};

// create the ghosts
var blinky = new Ghost();
var pinky = new Ghost();
var inky = new Ghost();
var clyde = new Ghost();
var ghosts = [ blinky, pinky, inky, clyde ];

// initialize the ghosts
var initGhosts = function() {

    // initialize blinky
    blinky.setDir(DIR_LEFT);
    blinky.setPos(size*tileCols/2, 14*size+mid.y);
    blinky.color = "rgb(200,0,0)";
};

//
// ============== PAC-MAN ACTOR ==============
//

var MODE_PACMAN_NORM = 0;
var MODE_PACMAN_ENERGY = 1;

var Pacman = function() {
    Actor.apply(this);
    this.nextDir = {};
    this.nextDirEnum = 0;
};
Pacman.prototype.__proto__ = Actor.prototype;

// sets the next direction and updates its dependent variables
Pacman.prototype.setNextDir = function(nextDirEnum) {
    setDirFromEnum(this.nextDir, nextDirEnum);
    this.nextDirEnum = nextDirEnum;
};

Pacman.prototype.getStepPattern = function() {
    var pattern;
    if (this.mode == MODE_PACMAN_NORM) 
        return STEP_PACMAN;
    else if (this.mode == MODE_PACMAN_ENERGY) 
        return STEP_PACMAN_FRIGHT;
};

// move forward
Pacman.prototype.step = function() {

    var a = (this.dir.x != 0) ? 'x' : 'y'; // axis of motion
    var b = (this.dir.x != 0) ? 'y' : 'x'; // axis perpendicular to motion

    // Don't proceed past the middle of a tile if facing a wall
    var stop = this.distToMid[a] == 0 && !isTileWalkable(getNextTile(this.tile, this.dir));
    if (!stop)
        this.pixel[a] += this.dir[a];

    // Drift toward the center of the track (a.k.a. cornering)
    this.pixel[b] += sign(this.distToMid[b]);

    this.commitPos();

    // TODO: HANDLE EATING:
    // stop for 1 frame when eat pill
    // reverse ghost direction when eat energizer
    // increase speed when eat energizer and stop for 3 frames
};

// determine direction
Pacman.prototype.steer = function() {
    // head in the desired direction if possible
    if (isTileWalkable(getNextTile(this.tile, this.nextDir)))
        this.setDir(this.nextDirEnum);
};

var pacman = new Pacman();

var initPacman = function() {
    pacman.setDir(DIR_LEFT);
    pacman.setPos(size*tileCols/2, 26*size + mid.y);
    pacman.color = "rgb(255,215,0)";
};

//
// =============== USER INPUT ==================
//

// get mouse position relative to canvas
// from: http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
var getMousePos = function(canvas, evt) {
    // get canvas position
    var obj = canvas;
    var top = 0;
    var left = 0;
    while (obj.tagName != 'BODY') {
        top += obj.offsetTop;
        left += obj.offsetLeft;
        obj = obj.offsetParent;
    }

    // return relative mouse position
    var mouseX = evt.clientX - left + window.pageXOffset;
    var mouseY = evt.clientY - top + window.pageYOffset;
    return { x: mouseX, y: mouseY };
};

var initInput = function() {
    // for debugging
    // set blinky's target tile using the mouse position
    // canvas.addEventListener("mousemove", function(evt) {
    //     var mousePos = getMousePos(canvas,evt);
    //     blinky.target.x = Math.floor(mousePos.x / size);
    //     blinky.target.y = Math.floor(mousePos.y / size);
    // }, false);
    
    // make "focusable" to isolate keypresses when canvas is clicked
    canvas.tabIndex = 0;

    // activate input focus
    canvas.onmousedown = function(e) {
        this.focus();
    };

    // handle key press event
    canvas.onkeydown = function(e) {
        var key = (e||window.event).keyCode;
        switch (key) {
            case 65: case 37: pacman.setNextDir(DIR_LEFT); break; // left
            case 87: case 38: pacman.setNextDir(DIR_UP); break; // up
            case 68: case 39: pacman.setNextDir(DIR_RIGHT); break; // right
            case 83: case 40: pacman.setNextDir(DIR_DOWN); break;// down
        }
    };

};

//
// ================ GAME STATE ===================
//

var level = 1;

// initialize the game
var initGame = function() {

    resetTiles();
    initPacman();
    initGhosts();
    initInput();

    setInterval(updateGame, 1000/60); // update at 60Hz (original arcade rate)
    setInterval(drawGame, 1000/25);   // draw at 25Hz (helps performance)
};

// update the game state
var updateGame = function() {
    blinky.update();
    pacman.update();
};

// draw the game state
var drawGame = function() {
    ctx.clearRect(0,0,ctx_w,ctx_h);
    drawTiles();
    blinky.draw();
    pacman.draw();
};

//
// =========== MAIN SETUP ==========
//

// return sign of a number
var sign = function(x) {
    if (x<0) return -1;
    if (x>0) return 1;
    return 0;
};

var canvas;
var ctx, ctx_w, ctx_h;

window.onload = function() {
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");
    ctx_w = ctx.canvas.width;
    ctx_h = ctx.canvas.height;
    initGame();
};


//
// ============= END ===============
//
</script>
</head>
<body>
<canvas id="canvas" width="224" height="288" style="border:1px solid #DDD; outline:none;"></canvas>
<p>
built following reverse-engineered research from <a href="http://home.comcast.net/~jpittman2/pacman/pacmandossier.html">The Pac-Man Dossier</a>.
</p>
</body>
