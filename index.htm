<head>
<script>

//
// =========== TILE MAP ============
//

var tileCols = 28;
var tileRows = 36;

// initial tile state
var tiles = (
"____________________________" +
"____________________________" +
"____________________________" +
"||||||||||||||||||||||||||||" +
"|............||............|" +
"|.||||.|||||.||.|||||.||||.|" +
"|o|__|.|___|.||.|___|.|__|o|" +
"|.||||.|||||.||.|||||.||||.|" +
"|..........................|" +
"|.||||.||.||||||||.||.||||.|" +
"|.||||.||.||||||||.||.||||.|" +
"|......||....||....||......|" +
"||||||.||||| || |||||.||||||" +
"_____|.||||| || |||||.|_____" +
"_____|.||          ||.|_____" +
"_____|.|| |||--||| ||.|_____" +
"||||||.|| |______| ||.||||||" +
"      .   |______|   .      " +
"||||||.|| |______| ||.||||||" +
"_____|.|| |||||||| ||.|_____" +
"_____|.||          ||.|_____" +
"_____|.||.||||||||.||.|_____" +
"||||||.||.||||||||.||.||||||" +
"|............||............|" +
"|.||||.|||||.||.|||||.||||.|" +
"|.||||.|||||.||.|||||.||||.|" +
"|o..||.......  .......||..o|" +
"|||.||.||.||||||||.||.||.|||" +
"|||.||.||.||||||||.||.||.|||" +
"|......||....||....||......|" +
"|.||||||||||.||.||||||||||.|" +
"|.||||||||||.||.||||||||||.|" +
"|..........................|" +
"||||||||||||||||||||||||||||" +
"____________________________" +
"____________________________");

// current tile state
var currentTiles;
var resetTiles = function() {
    dotCount = 0;
    currentTiles = tiles.split("");
};

// offscreen tiles for tunnel
var isOffscreenTunnelTile = function(x,y) {
    return (y == 17 && (x<0 || x>tileCols-1));
};
var getTile = function(x,y) {
    if (x>=0 && x<tileCols && y>=0 && y<tileRows) 
        return currentTiles[x+y*tileCols];
    if (isOffscreenTunnelTile(x,y))
        return ' ';
};

// location of the ghost door and home boundary
var ghostDoorTile = {x:13, y:14};
var ghostDoorPixel = {x:ghostDoorTile.x*size + 7, y:ghostDoorTile.y*size + mid.y};
var ghostHomeLeftPixel = ghostDoorPixel.x - 2*size;
var ghostHomeRightPixel = ghostDoorPixel.x + 2*size;
var ghostHomeTopPixel = 17*size;
var ghostHomeBottomPixel = 18*size;

//
// ========== TILE DRAWING ============
//

var size = 8;         // tile size
var mid = {x:3, y:4}; // x,y center of a tile

var drawBackground = function() {
    ctx.fillStyle = "#333";
    ctx.fillRect(0,0,ctx_w,ctx_h);
};
var drawPill = function(x,y,c,s) {
    ctx.fillStyle = c;
    ctx.fillRect(x*size + mid.x - s/2, y*size + mid.y - s/2, s, s);
};
var drawFloor = function(x,y,c,p) {
    ctx.fillStyle = c;
    ctx.fillRect(x*size+p,y*size+p,size-2*p,size-2*p);
};
var drawActor = function(px,py,c,s) {
    ctx.fillStyle = c;
    ctx.fillRect(px-s/2, py-s/2, s, s);
};

var cellDraw = {};
cellDraw['|'] = function(x,y) { }; // wall
cellDraw['.'] = function(x,y) { drawFloor(x,y,"#888",0); }; // pellet
cellDraw['o'] = function(x,y) { drawFloor(x,y,"#FFF",0); }; // energizer
cellDraw[' '] = function(x,y) { drawFloor(x,y,"#555",0); }; // walkable space
cellDraw['_'] = function(x,y) { }; // dead space
cellDraw['-'] = function(x,y) { }; // ghost door

var isTileWalkable = function(t) {
    return t==' ' || t=='.' || t=='o';
};

var drawTiles = function () {
    var x,y;
    var i=0;
    for (y=0; y<tileRows; y++)
    for (x=0; x<tileCols; x++)
        cellDraw[currentTiles[i++]](x,y);
};

//
// ============ TILE DIRECTION ============
// 

// direction enums (in order of ghost turn preference)
var DIR_UP = 0;
var DIR_LEFT = 1;
var DIR_DOWN = 2;
var DIR_RIGHT = 3;

// get direction enum from a direction vector
var getEnumFromDir = function(dir) {
    if (dir.x==-1) return DIR_LEFT;
    if (dir.x==1) return DIR_RIGHT;
    if (dir.y==-1) return DIR_UP;
    if (dir.y==1) return DIR_DOWN;
};

// set direction vector from a direction enum
var setDirFromEnum = function(dir,dirEnum) {
    if (dirEnum == DIR_UP)         { dir.x = 0; dir.y =-1; }
    else if (dirEnum == DIR_LEFT)  { dir.x =-1; dir.y = 0; }
    else if (dirEnum == DIR_DOWN)  { dir.x = 0; dir.y = 1; }
    else if (dirEnum == DIR_RIGHT) { dir.x = 1; dir.y = 0; }
};

// get a list of the four surrounding tiles
var getSurroundingTiles = function(tile) {
    return [
        getTile(tile.x, tile.y-1), // DIR_UP
        getTile(tile.x-1, tile.y), // DIR_LEFT
        getTile(tile.x, tile.y+1), // DIR_DOWN
        getTile(tile.x+1, tile.y)  // DIR_RIGHT
    ];
};

// get a tile next to the given tile
var getNextTile = function(tile, dir) {
    return getTile(tile.x+dir.x, tile.y+dir.y);
};

//
// ============ ACTOR SPEEDS ============
//

// speed control table (from Jamey Pittman)
var stepSizes = (
                     // LEVEL 1
"1111111111111111" + // pac-man (normal)
"0111111111111111" + // ghosts (normal)
"1111211111112111" + // pac-man (fright)
"0110110101101101" + // ghosts (fright)
"0101010101010101" + // ghosts (tunnel)
"1111111111111111" + // elroy 1
"1111111121111111" + // elroy 2

                     // LEVELS 2-4
"1111211111112111" + // pac-man (normal)
"1111111121111111" + // ghosts (normal)
"1111211112111121" + // pac-man (fright)
"0110110110110111" + // ghosts (fright)
"0110101011010101" + // ghosts (tunnel)
"1111211111112111" + // elroy 1
"1111211112111121" + // elroy 2

                     // LEVELS 5-20
"1121112111211121" + // pac-man (normal)
"1111211112111121" + // ghosts (normal)
"1121112111211121" + // pac-man (fright) (N/A for levels 17, 19 & 20)
"0111011101110111" + // ghosts (fright)  (N/A for levels 17, 19 & 20)
"0110110101101101" + // ghosts (tunnel)
"1121112111211121" + // elroy 1
"1121121121121121" + // elroy 2

                     // LEVELS 21+
"1111211111112111" + // pac-man (normal)
"1111211112111121" + // ghosts (normal)
"0000000000000000" + // pac-man (fright) N/A
"0000000000000000" + // ghosts (fright)  N/A
"0110110101101101" + // ghosts (tunnel)
"1121112111211121" + // elroy 1
"1121121121121121"); // elroy 2

// used as "pattern" parameter in getStepSize()
var STEP_PACMAN = 0;
var STEP_GHOST = 1;
var STEP_PACMAN_FRIGHT = 2;
var STEP_GHOST_FRIGHT = 3;
var STEP_GHOST_TUNNEL = 4;
var STEP_ELROY1 = 5;
var STEP_ELROY2 = 6;

// getter function to extract a step size from the table
var getStepSize = function(level, pattern, frame) {
    var entry;
    if (level < 1) return;
    else if (level==1)                  entry = 0;
    else if (level >= 2 && level <= 4)  entry = 1;
    else if (level >= 5 && level <= 20) entry = 2;
    else if (level >= 21)               entry = 3;
    return stepSizes[entry*7*16 + pattern*16 + frame%16];
};

//
// ============= COMMON ACTOR ==============
//

var Actor = function() {
    this.mode = 0;
    this.startPixel = {};    // x,y pixel starting position (0<=x<tileCols*size, 0<=y<tileRows*size)
    this.startDirEnum = 0; // starting direction enumeration (0<=x,y<=4)
    this.tile = {};        // x,y tile position (0<=x<tileCols, 0<=y<tileRows)
    this.pixel = {};       // x,y pixel position (0<=x<tileCols*size, 0<=y<tileRows*size)
    this.tilePixel = {};   // x,y pixel in tile (0<=x,y<size)
    this.distToMid = {};   // x,y pixel distance from center of tile
    this.dir = {};         // x,y direction (-1<=x,y<=1)
    this.dirEnum = 0;      // direction enumeration (0<=x,y<=4)
    this.frame = 0;        // frame count
    this.color = 0;
};

// reset position and direction
Actor.prototype.resetPosAndDir = function() {
    this.setDir(this.startDirEnum);
    this.setPos(this.startPixel.x, this.startPixel.y);
};

// function called when new level begins
Actor.prototype.onNewLevel = function() {
    this.resetPosAndDir();
};

// function called when pacman dies and level restarts
Actor.prototype.onRestartLevel = function() {
    this.resetPosAndDir();
};

// sets the position and updates its dependent variables
Actor.prototype.setPos = function(px,py) {
    this.pixel.x = px;
    this.pixel.y = py;
    this.commitPos();
};

// updates the position's dependent variables
Actor.prototype.commitPos = function() {

    // teleport position to opposite side of map if past tunnel tiles
    // (there are two invisible tiles on each side of the tunnel)
    if (isOffscreenTunnelTile(this.tile.x, this.tile.y))
        if (this.pixel.x == -2*size-1)
            this.pixel.x = (tileCols+2)*size-1;
        else if (this.pixel.x == (tileCols+2)*size)
            this.pixel.x = -2*size;

    this.tile.x = Math.floor(this.pixel.x / size);
    this.tile.y = Math.floor(this.pixel.y / size);
    this.tilePixel.x = this.pixel.x % size;
    this.tilePixel.y = this.pixel.y % size;
    this.distToMid.x = mid.x - this.tilePixel.x;
    this.distToMid.y = mid.y - this.tilePixel.y;
};

// sets the direction and updates its dependent variables
Actor.prototype.setDir = function(dirEnum) {
    setDirFromEnum(this.dir, dirEnum);
    this.dirEnum = dirEnum;
};

// updates the actor state
Actor.prototype.update = function() {
    // get number of steps to advance in this frame
    var steps = getStepSize(level, this.getStepPattern(), this.frame);
    var i;
    for (i=0; i<steps; i++) {
        this.step();
        this.steer();
    }
    this.frame += 1;
};

// draws the actor
Actor.prototype.draw = function() {
    drawActor(this.pixel.x, this.pixel.y, this.color, 20);
};

//
// ============== GHOST ACTOR ==============
//

var MODE_GHOST_CHASE = 0;
var MODE_GHOST_SCATTER = 1;
var MODE_GHOST_FRIGHT = 2;

// Ghost constructor
var Ghost = function() {
    Actor.apply(this);    // inherit data from Actor

    this.color = 0;

    // current and home targets
    this.targetTile = {x:0,y:0};     // x,y target tile (0<=x<tileCols, 0<=y<tileRows)
    this.homeTile = {};       // x,y home tile (0<=x<tileCols, 0<=y<tileRows)

    // reversal info
    this.reverse = false; // reverse signal
    this.reverseTile = {}; // x,y tile to reverse direction after leaving

    // home-related flags
    this.justDied = false;
    this.goingHome = false;
    this.pacingHome = false;
    this.leavingHome = false;

    // TODO: timers
    // chase/scatter, fright, pace
};
Ghost.prototype.__proto__ = Actor.prototype; // inherit functions from Actor

// gets the step pattern (speed) used in speed control table
Ghost.prototype.getStepPattern = function() {
    //TODO: speeds for home flags
    if (this.mode == MODE_GHOST_CHASE || this.mode == MODE_GHOST_SCATTER) {
        if (this.tile.y == 17 && (this.tile.x <= 5 || this.tile.x >= tileCols-1-5))
            return STEP_GHOST_TUNNEL;
        return STEP_GHOST;
    }
    else
        return STEP_GHOST_FRIGHT;
};

// determines if this ghost is inside the ghost home
Ghost.prototype.isInsideHome = function() {
    return (this.pixel.x >= ghostHomeLeftPixel && this.pixel.x <= ghostHomeRightPixel &&
        this.tile.y > ghostDoorTile.y && this.pixel.y <= ghostHomeBottomPixel);
};

// signal ghost to reverse direction after leaving current tile
Ghost.prototype.signalReverse = function() {
    this.reverseTile.x = this.tile.x;
    this.reverseTile.y = this.tile.y;
    this.reverse = true;
};

Ghost.prototype.onEnergyEat = function() {
    if (!this.isInsideHome())
        this.signalReverse();

    // TODO: add level condition to prevent fright
    mode = MODE_GHOST_FRIGHT;
};

Ghost.prototype.onEaten = function() {
    this.justDied = true;
};

Ghost.prototype.onNewLevel = function() {
    // TODO: enable dot counter?
};

Ghost.prototype.onRestartLevel = function() {
    // TODO: disable dot counter?
};

// move forward
Ghost.prototype.step = function() {
    this.setPos(this.pixel.x+this.dir.x, this.pixel.y+this.dir.y);
};

// determine direction
Ghost.prototype.steer = function() {

    // initially, only consider a turn if we're at the middle of a tile
    // (overridden to true later if we're just leaving home)
    var considerTurning = (this.distToMid.x == 0 && this.distToMid.y == 0);

    // heading home
    if (this.goingHome) {
        // at the doormat
        if (this.tile.x == ghostDoorTile.x && this.tile.y == ghostDoorTile.y) {
            // walk to the door, or go through if already there
            this.setDir(this.pixel.x == ghostDoorPixel.x ? DIR_DOWN : DIR_RIGHT);
            return;
        }

        // inside
        if (this.isInsideHome()) {
            if (this.pixel.y == this.ghostHomeBottomPixel) {
                // revive
                if (this.pixel.x == this.startPixel.x) {
                    this.goingHome = false;
                    this.pacingHome = true;
                    this.setDir(DIR_UP);
                    // TODO: change mode ?
                }
                // sidestep to its seat
                else {
                    this.setDir(this.startPixel.x < this.pixel.x ? DIR_LEFT : DIR_RIGHT);
                }
            }
            // keep walking down
            return;
        }

        // still outside, so keep looking for the door
    }
    // pacing home
    else if (this.pacingHome) {

        // pace back and forth
        if (this.shouldStayHome()) { // TODO: implement shouldStayHome()
            if (this.pixel.y == ghostHomeTopPixel)
                this.setDir(DIR_DOWN);
            else if (this.pixel.y == ghostHomeBottomPixel)
                this.setDir(DIR_UP);
        }
        // head for the door
        else {
            this.leavingHome = true;
            if (this.pixel.x == ghostDoorPixel.x)
                this.setDir(DIR_UP);
            else
                this.setDir(this.pixel.x < ghostDoorPixel.x ? DIR_RIGHT : DIR_LEFT);
        }
        return;
    }
    // leaving home
    else if (this.leavingHome) {
        if (this.pixel.x == ghostDoorPixel.x && this.pixel.y == ghostDoorPixel.y) {
            this.leavingHome = false;
            considerTurning = true;
        }
        else if (this.pixel.x == ghostDoorPixel.x) {
            this.setDir(DIR_UP);
            return;
        }
    }

    var dirEnum;
    var blocked;

    var dir = {};
    var oppDirEnum = (this.dirEnum+2)%4;
    var i,dx,dy;
    var dist,minDist = Infinity;

    var surroundTiles;

    // reverse direction once we exit the tile occupied when reverse signal was given
    if (this.reverse && !(this.tile.x == this.reverseTile.x && this.tile.y == this.reverseTile.y)) {
        this.reverse = false;
        this.setDir(oppDirEnum);
        return;
    }

    // exit if not considering turning
    if (!considerTurning)
        return;

    // get blocked passages
    surroundTiles = getSurroundingTiles(this.tile);
    blocked = [1,1,1,1];
    for (i=0; i<4; i++) {
        blocked[i] = !isTileWalkable(surroundTiles[i]);
    }

    // not allowed to turn around
    blocked[oppDirEnum] = true;

    // random turn if frightened
    if (this.mode == MODE_GHOST_FRIGHT) {
        dirEnum = Math.floor(Math.random()*5);
        while (blocked[dirEnum])
            dirEnum = (dirEnum+1)%4;
    }
    else {
        // set target
        if (this.mode == MODE_GHOST_SCATTER) {
            this.targetTile.x = this.homeTile.x;
            this.targetTile.y = this.homeTile.y;
        }
        else // mode == MODE_GHOST_CHASE
            this.setTarget();

        // not allowed to go up at these points
        if ((this.tile.x == 12 || this.tile.x == 15) && (this.tile.y == 14 || this.tile.y == 26))
            blocked[DIR_UP] = true;

        // choose direction that minimizes distance to target
        for (i=0; i<4; i++) if (!blocked[i]) {
            setDirFromEnum(dir,i);
            dx = dir.x + this.tile.x - this.target.x;
            dy = dir.y + this.tile.y - this.target.y;
            dist = dx*dx+dy*dy;
            if (dist < minDist) {
                minDist = dist;
                dirEnum = i;
            }
        }
    }

    // commit the direction
    this.setDir(dirEnum);
};

Ghost.prototype.update = function() {

    // when the ghost is eaten, signal that it has taken its first step back home
    // (this is to allows the dead ghost to remain traveling while the playState freezes all other actors)
    if (this.mode == MODE_GHOST_DEAD)
        this.isGoingHome = true;
    
    // call super function to update position and direction
    Actor.prototype.update.apply(this);
};

Ghost.prototype.draw = function() {
    if (this.mode == MODE_GHOST_FRIGHT)
        drawActor(this.pixel.x, this.pixel.y, "#00F", 20);
    else if (this.mode == MODE_GHOST_DEAD)
        drawActor(this.pixel.x, this.pixel.y, "rgba(255,255,255,0.2)", 20);
    else 
        Actor.prototype.draw.apply(this);
};

// draw the line of sight of the ghost (for visualization)
Ghost.prototype.drawSight = function() {
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.pixel.x, this.pixel.y);
    ctx.lineTo(this.target.x*size+mid.x, this.target.y*size+mid.y);
    ctx.closePath();
    ctx.stroke();
    drawFloor(this.target.x,this.target.y, this.color,1);
};

//
// ============== PLAYER ACTOR ==============
//

var MODE_PLAYER_NORM = 0;
var MODE_PLAYER_ENERGY = 1;

// Pacman constructor
var Player = function() {
    Actor.apply(this);          // inherit data from Actor
    this.nextDir = {};          // x,y direction which reflects the player's controls
    this.nextDirEnum = 0;       // direction enumeration for nextDir
    this.skippedFramesLeft = 0;   // current # of frames skipped after energizing
};
Player.prototype.__proto__ = Actor.prototype; // inherit functions from Actor

Player.prototype.reset = function() {
    Actor.prototype.reset.apply(this);
    this.skippedFramesLeft = 0;
};

// sets the next direction and updates its dependent variables
Player.prototype.setNextDir = function(nextDirEnum) {
    setDirFromEnum(this.nextDir, nextDirEnum);
    this.nextDirEnum = nextDirEnum;
};

// gets the step pattern (speed) used in speed control table
Player.prototype.getStepPattern = function() {
    if (this.mode == MODE_PLAYER_NORM) 
        return STEP_PACMAN;
    else if (this.mode == MODE_PLAYER_ENERGY) 
        return STEP_PACMAN_FRIGHT;
};

// move forward
Player.prototype.step = function() {

    var a = (this.dir.x != 0) ? 'x' : 'y'; // axis of motion
    var b = (this.dir.x != 0) ? 'y' : 'x'; // axis perpendicular to motion

    // Don't proceed past the middle of a tile if facing a wall
    var stop = this.distToMid[a] == 0 && !isTileWalkable(getNextTile(this.tile, this.dir));
    if (!stop)
        this.pixel[a] += this.dir[a];

    // Drift toward the center of the track (a.k.a. cornering)
    this.pixel[b] += sign(this.distToMid[b]);

    this.commitPos();
};

// determine direction
Player.prototype.steer = function() {
    // head in the desired direction if possible
    if (isTileWalkable(getNextTile(this.tile, this.nextDir)))
        this.setDir(this.nextDirEnum);
};

Player.prototype.update = function() {

    // skip frames
    if (this.skippedFramesLeft > 0) {
        this.skippedFramesLeft -= 1;
        return;
    }

    // eat something
    var i;
    var t = getTile(this.tile.x, this.tile.y);
    if (t == '.' || t == 'o') {
        currentTiles[this.tile.x+this.tile.y*tileCols] = ' ';
        dotCount += 1;
        if (dotCount == 244) {
            state = finishState;
            return;
        }
        if (t == 'o') {
            this.skippedFramesLeft = 2;
            for (i=0; i<4; i++) 
                actors[i].onEnergyEat();
        }
        return; // don't update position this frame
    }

    // call super function to update position and direction
    Actor.prototype.update.apply(this);
};

//
// ================ ACTOR DEFINITIONS ==============
// 

// create blinky
var blinky = new Ghost();
blinky.color = "#FF0000";
blinky.startDirEnum = DIR_LEFT;
blinky.startPixel.x = 14*size-1;
blinky.startPixel.y = 14*size+mid.y;
blinky.homeTile.x = tileCols-1-2;
blinky.homeTile.y = 0;
blinky.setTarget = function() {
    // directly target pacman
    this.targetTile.x = pacman.tile.x;
    this.targetTile.y = pacman.tile.y;
};
// TODO: override getStepPattern function to trigger elroy states

// create pinky
var pinky = new Ghost();
pinky.color = "#FFB8FF";
pinky.startDirEnum = DIR_RIGHT;
pinky.startPixel.x = 14*size-1;
pinky.startPixel.y = 17*size+mid.y;
pinky.homeTile.x = 2;
pinky.homeTile.y = 0;
pinky.setTarget = function() {
    // target four tiles ahead of pacman
    this.targetTile.x = pacman.tile.x + 4*pacman.dir.x;
    this.targetTile.y = pacman.tile.y + 4*pacman.dir.y;
    if (pacman.dirEnum == DIR_UP)
        this.targetTile.x -= 4; // arcade overflow bug
};
pinky.getDotLimit = function() { return 0; };

// create inky
var inky = new Ghost();
inky.color = "#00FFFF";
inky.startDirEnum = DIR_DOWN;
inky.startPixel.x = 12*size-1;
inky.startPixel.y = 17*size + mid.y;
inky.homeTile.x = tileCols-1;
inky.homeTile.y = tileRows - 2;
inky.setTarget = function() {
    // target twice the distance from blinky to two tiles ahead of pacman
    var px = pacman.tile.x + 2*pacman.dir.x;
    var py = pacman.tile.y + 2*pacman.dir.y;
    if (pacman.dirEnum == DIR_UP)
        px -= 2; // arcade overflow bug
    this.targetTile.x = blinky.tile.x + 2*(px - blinky.tile.x);
    this.targetTile.y = blinky.tile.y + 2*(py - blinky.tile.y);
};
inky.getDotLimit = function() { return (level==1) ? 30 : 0; };

// create clyde
var clyde = new Ghost();
clyde.color = "#FFB851";
clyde.startDirEnum = DIR_RIGHT;
clyde.startPixel.x = 16*size-1;
clyde.startPixel.y = 17*size + mid.y;
clyde.home.x = 0;
clyde.home.y = tileRows-2;
clyde.setTarget = function() {
    // target pacman if >=8 tiles away, otherwise go home
    var dx = pacman.tile.x - this.tile.x;
    var dy = pacman.tile.y - this.tile.y;
    var dist = dx*dx+dy*dy;
    if (dist >= 64) {
        this.targetTile.x = pacman.tile.x;
        this.targetTile.y = pacman.tile.y;
    }
    else {
        this.targetTile.x = this.homeTile.x;
        this.targetTile.y = this.homeTile.y;
    }
};
clyde.getDotLimit = function() {
    if (level == 1) return 60;
    else if (level == 2) return 50;
    else return 0;
};

// create pacman
var pacman = new Player();
pacman.color = "#FFFF00";
pacman.startDirEnum = DIR_LEFT;
pacman.startPixel.x = size*tileCols/2;
pacman.startPixel.y = 26*size + mid.y;

//
// ============== ACTOR MANAGEMENT ==================
//

// order at which they appear in original arcade memory
// (suggests drawing/update order)
var actors = [blinky, pinky, inky, clyde, pacman];

var drawActors = function() {
    var i;
    if (pacman.mode == MODE_PLAYER_ENERGY)
        for (i=0; i<=4; i++) 
            actors[i].draw();
    else
        for (i=4; i>=0; i--) 
            actors[i].draw();
};

//
// ================ COUNTERS =================
//



//
// ================ GAME STATES ===================
//

var state;     // current state object
var level = 1; // current level
var lives = 2; // current lives
var dotCount;  // current number of dots eaten

// switch to the given state
var switchToState = function(s) {
    s.init();
    state = s;
};

// start state
var startState = {};
startState.init = function() {
    initTiles();
    var i;
    for (i=0; i<5; i++)
        actors[i].onNewLevel();
    this.frame = 0;
    this.text = "ready";
    this.textWidth = ctx.measureText(this.text).width;
};
startState.draw = function() {
    drawBackground();
    drawTiles();
    drawActors();
    ctx.fillStyle = "#FF0";
    ctx.fillText(this.text, tileCols*size/2 - this.textWidth/2, 17*size+mid.y);
};
startState.update = function() {
    if (this.frame == 2*60)
        switchToState(playState);
    this.frame += 1;
};

// restart state
var restartState = {};
restartState.init = function() {
    var i;
    for (i=0; i<5; i++)
        actors[i].onNewLevel();
    this.frame = 0;
    this.text = "ready";
    this.textWidth = ctx.measureText(this.text).width;
};
restartState.draw = function() {
    drawBackground();
    drawTiles();
    drawActors();
    ctx.fillStyle = "#FF0";
    ctx.fillText(this.text, tileCols*size/2 - this.textWidth/2, 17*size+mid.y);
};
restartState.update = function() {
    if (this.frame == 2*60)
        switchToState(playState);
    this.frame += 1;
};

// play state
var playState = {};
playState.init = function() {
    this.skippedFramesLeft = 0;
};
playState.draw = function() {
    drawBackground();
    drawTiles();
    drawActors();
};
playState.update = function() {

    var skip = this.skippedFramesLeft > 0;

    // if we're skipping this frame, we still need to update the dead ghosts running home
    var i;
    for (i = 0; i<5; i++)
        if (!skip || (i<4 && actors[i].mode == MODE_GHOST_DEAD && actors[i].isGoingHome))
            actors[i].update();

    if (skip) {
        this.skippedFramesLeft -= 1;
        return;
    }

    // test pacman collision with each ghost
    for (i = 0; i<4; i++) {
        if (actors[i].tile.x == pacman.tile.x && actors[i].tile.y == pacman.tile.y) {
            if (actors[i].mode == MODE_GHOST_CHASE || actors[i].mode == MODE_GHOST_SCATTER) {
                switchToState(deadState);
                return;
            }
            else if (pacman.mode == MODE_PLAYER_ENERGY) {
                actors[i].onEaten();
                this.skippedFramesLeft = 120;
                return;
            }
        }
    }
};

// dead state
var deadState = {};
deadState.init = function() { };
deadState.draw = function() { };
deadState.update = function() { };

// finish state
var finishState = {};
finishState.init = function() { };
finishState.draw = function() { };
finishState.update = function() { };

//
// =============== USER INPUT ==================
//

var initInput = function() {
    // make "focusable" to isolate keypresses when canvas is clicked
    canvas.tabIndex = 0;

    // activate input focus
    canvas.onmousedown = function(e) {
        this.focus();
    };

    // handle key press event
    canvas.onkeydown = function(e) {
        var key = (e||window.event).keyCode;
        switch (key) {
            case 65: case 37: pacman.setNextDir(DIR_LEFT); break; // left
            case 87: case 38: pacman.setNextDir(DIR_UP); break; // up
            case 68: case 39: pacman.setNextDir(DIR_RIGHT); break; // right
            case 83: case 40: pacman.setNextDir(DIR_DOWN); break;// down
        }
    };
};



//
// =========== MAIN SETUP ==========
//

// return sign of a number
var sign = function(x) {
    if (x<0) return -1;
    if (x>0) return 1;
    return 0;
};

var canvas;
var ctx, ctx_w, ctx_h;

window.onload = function() {
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");
    ctx_w = ctx.canvas.width;
    ctx_h = ctx.canvas.height;
    ctx.font = "bold 12px sans-serif";
    initInput();

    this.switchToState(startState);
    setInterval("state.update()", 1000/60); // update at 60Hz (original arcade rate)
    setInterval("state.draw()", 1000/25);   // draw at 25Hz (helps performance)
};


//
// ============= END ===============
//
</script>
</head>
<body>
<canvas id="canvas" width="224" height="288" style="border:1px solid #DDD; outline:none;"></canvas>
<p>
based on the <a href="http://home.comcast.net/~jpittman2/pacman/pacmandossier.html">The Pac-Man Dossier</a>.<br/>
project tracked on <a href="https://github.com/shaunew/Pac-Man">GitHub</a>
</p>
</body>
